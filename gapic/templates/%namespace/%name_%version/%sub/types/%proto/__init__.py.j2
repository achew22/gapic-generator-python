{% extends "_base.py.j2" %}

{% block content %}

{% with p = proto.disambiguate('proto') %}
{% if proto.messages|length or proto.all_enums|length %}
import proto{% if p != 'proto' %} as {{ p }}{% endif %}  # type: ignore
{% endif %}

{% filter sort_lines %}
{% for import_ in proto.python_modules %}
{{ import_ }}
{% endfor %}
{% endfilter %}


__protobuf__ = {{ p }}.module(
    package='{{ '.'.join(proto.meta.address.package) }}',
    {% if api.naming.proto_package != '.'.join(proto.meta.address.package) %}
    marshal='{{ api.naming.proto_package }}',
    {% endif %}
    manifest={
    {% for enum in proto.enums.values() %}
        '{{ enum.name }}',
    {% endfor %}
    {% for message in proto.messages.values() %}
        '{{ message.name }}',
    {% endfor %}
    },
)

{# Few words about the has_other variable... #}
{# Because of https://github.com/googleapis/gapic-generator-python/issues/1252 #}
{# There has to be a limit to how big the auto-generated files can be. (The files generated #}
{# for the python-compute library were too big for example.) That's why, for big protos #}
{# that have big number of messages divided, they get split into 3 files: this file, requests.py and responses.py #}
{# This way, the files aren't too big and everyone is happy. #}
{# Why not do the split for EVERY proto? Because for some reason, due to the metaclass magic of proto.Message class, #}
{# THERE ALWAYS HAS TO BE AT LEAST ONE CLASS DEFINED IN THIS (__init__.py) FILE! #}
{# Without a class definition here, there will be errors and the classes won't get initialized properly. #}
{# That's why, if a protocol has a type that's not a request nor response, it will get split into multiple files. #}
{# If it doesn't have a type like that (likely a small proto), everything will be defined in this file alone. #}
{% if has_other %}

{% if has_requests %}
from .requests import (
    {% for enum in proto.enums.values() %}
        {% if enum.name.endswith('Request') %}
        {{enum.name}},
        {% endif %}
    {% endfor %}
    {% for message in proto.messages.values() %}
        {% if message.name.endswith('Request') %}
        {{message.name}},
        {% endif %}
    {% endfor %}
)
{% endif %}

{% if has_responses %}
from .responses import (
    {% for enum in proto.enums.values() %}
        {% if enum.name.endswith('Response') %}
        {{enum.name}},
        {% endif %}
    {% endfor %}
    {% for message in proto.messages.values() %}
        {% if message.name.endswith('Response') %}
        {{message.name}},
        {% endif %}
    {% endfor %}
)
{% endif %}

{% for enum in proto.enums.values() %}
    {% if not (enum.name.endswith('Request') or enum.name.endswith('Response')) %}
    {% include '%namespace/%name_%version/%sub/types/_enum.py.j2' with context %}
    {% endif %}
{% endfor %}

{% for message in proto.messages.values() %}
    {% if not (message.name.endswith('Request') or message.name.endswith('Response')) %}
    {% include "%namespace/%name_%version/%sub/types/_message.py.j2" with context %}
    {% endif %}
{% endfor %}

{% else %}

{% for enum in proto.enums.values() %}
    {% include '%namespace/%name_%version/%sub/types/_enum.py.j2' with context %}
{% endfor %}

{% for message in proto.messages.values() %}
    {% include "%namespace/%name_%version/%sub/types/_message.py.j2" with context %}
{% endfor %}

{% endif %}
{% endwith %}

__all__ = tuple(sorted(__protobuf__.manifest))
{% endblock %}
